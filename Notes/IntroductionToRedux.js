
/*
  Do I need Redux?
    - Complex data flows
    - Inter-component communication
    - Non-heirarchical data
    - Many actions
    - Same data used in multiple places

  Three Principles
    - one immutable store (can't be changed)
    - Actions trigger changes to the store
    - Reducers update state - function that accepts the current state in an action and returns the new state

  Flux vs Redux
    - Unidirectional Flow
    - Actions
    - Single store for redux and multiple stores for Flux
    - Single store with hierarchical reducers
    - No dispatcher for redux while there is one for Flux
    - State is immutable in redux while it is in flux


  Redux Flow
    - Action describes user intent, it is an object with a type and a date load
      {type: RATE_COURSE, rating: 5}

    - The action will be handled by a reducers
      function appReducer(State = defualtState, action) {
        switch(action.type){
          case RATE_COURSE:
          //return the new state
        }
      }

    - One the new state is returned, the state is updated. React re-renders any
      componets that utilizes the data. They are connected to the store using react-redux


  Actions
    - type (manadatory)
    - data
    - are created by action creators
      rateCourse(rating) {
        return {type: RATE_COURSE, rating: rating}
      }

  Store - let store = createStore(reducer); //app entry level
    - store.dispatch(action)
    - store.subscribe(listener)
    - store.getState()
    - replaceReducer(nextReducer) //good for hot-reloading


  Immutability

  What it is ? - can change data, create new state everytime the state changes
    - Object.assign(target, ...sources) //create new object with a template
      ex: Object.assign({{}, state, {role: 'admin'}})

  Why immutable?
    - Clarity
    - Performance (if prevState !== storeState), rather than checking every property
    - Makes debugging easier

  Handling immutable state
    - Object.assign
    - Spread operator (for arrays)

  How do I enforce Immutability
    - redux-immutable-state-invarient(on development since they are heavyload work)

Reducers  - function that takes and an action and returns the new state
  - (state, action) => new state
  - function myReducer(state, action)
    {
      switch(action.type) {
        case 'INCREMENT_COUNTER' :
          return (Object.assign({}, state, {counter: state.counter + 1}));
      }
    }

  - All Reducers are called on each dispatch
  - Reducer = "Slice of state"

 Two Component types
    Container             Presentational

    focus on how things work    focus on how things look
    Aware of Redux              Unaware of Redux
    Subscribe to Redux state    Read data from props
    Dispatch Redux actions      Invoke the callbacks passed in props
    Generated by react-redux    Written by hand

React-Reduc
  1 - Provider componet (application root)
    <Provider store={this.props.store}>
      <App/> //application top level component
    </Provider>

    - used once at the application root

  2- Connect (generates container components)
    - Wraps the component so that it connects it to the app store
      export default connect(
        mapStateToProps(function), //defining wt part of the app state
        mapDispatchToProps //actions as props
      )(AuthorPage)
    )


*/
